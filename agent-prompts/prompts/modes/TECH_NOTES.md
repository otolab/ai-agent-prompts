# 技術ノウハウ - Claude Code設定

## 作業品質の基本方針

### 完了判断の慎重性
- **解決・完了は目標だが、不十分な水準での完了判断はより危険**
- 完了だと感じても、ミスや予測外の出来事が見つかった場合は迷わず作業段階を戻す
- **調査→作業→確認の段階を必要に応じて反復実行**
- 「今度こそ完了！」というノリを避け、未知の出来事には慎重に対応
- **時間がかかることは悪いことではない** - 品質と信頼性を優先
- 予期しない動作・エラーが発生した場合は根本原因の解明を徹底

### ドキュメント・テスト・コード同期の原則

#### 基本原則
**ドキュメント・テスト・コードを往復して開発する作業において、「正とするのは何か」という判断があって、そこから作業が決まる**

#### 作業フロー
1. **不整合を発見したら、まず「何を正とするか」を判断**
   - これは固定的なルールではなく、状況に応じた判断
   - 現在の開発フェーズ、変更の目的、品質の状態を考慮

2. **正の判断基準例**
   - 探索的開発：動作するコードが正（実装を通じて仕様を発見）
   - テスト駆動開発：テストが正（望ましい振る舞いを定義）
   - 仕様変更：新しい要求が正（ドキュメント・コード・テストすべて修正対象）
   - バグ修正：期待される動作が正（ドキュメントまたはテストに記載）
   - リファクタリング：テストが正（振る舞いを変えずに実装を改善）

3. **正を決めたら、それに合わせて他を修正**
   - 正とした対象は変更しない
   - 正に合わせて他の要素を修正
   - 修正後、三者の整合性を確認

4. **往復開発の実践**
   - ドキュメント ⇄ コード ⇄ テストの間を往復
   - 各段階で「今何を正としているか」を明確に意識
   - 不整合を発見したら立ち止まって判断

#### 注意点
- **「正」は固定的ではない**：開発の進行とともに変化する
- **判断の根拠を明確に**：なぜそれを正としたかを説明できるように
- **整合性の確認を怠らない**：修正後は必ず三者の一致を確認

#### コード内コメント方針
- **意図を書く**: そこに何が書いてあるかではなく、それが何を意図しているのか書く
- **コメントが必要な場面**: 複雑な手順、理解しづらい内容、名前から想像しにくい本質を発見したとき
- **型をドキュメントとして活用**: 曖昧な型には十分に絞り込める説明的な型を付ける。型で表現困難な場合のみ自然言語で補足

### 「作りながら考える」開発スタイル

多くの開発は、一見矛盾する2つの前提に基づいています。

#### 2つの前提

1. **仕様のとおりに作ってください** - 実装は必ず文章化された仕様から作成される（絶対原則）
2. **仕様は完全ではありません** - 仕様は完全ではなく、開発しながら改善される（前提）

#### 矛盾の意味、対処方法

この矛盾は「作りながら考える」という開発プロセスで重要な意味を持ちます：

1. **実装時に問題に直面したら**：
  - 勝手に解決しようとしない（第1原則違反）
  - 作業の手を止める
  - ユーザに相談する

2. **仕様の検討フェーズ**：
  - 実装で発見した問題を報告
  - 仕様の曖昧さ・矛盾・実装不可能な点を明確化
  - ユーザと協議して仕様を改善

3. **改善後の実装フェーズ**：
  - 更新された仕様に従って実装
  - 第1原則「仕様のとおりに作る」に戻る

#### 重要な注意点

- **推測での実装は禁止**: 仕様が曖昧な場合は必ず確認
- **創造的解釈は避ける**: 仕様にないものを勝手に追加しない
- **問題の早期報告**: 実装が困難・不可能と判明したら即座に報告

この循環的なプロセスにより、実装と仕様の両方が段階的に改善されます。

## TypeScript/JavaScript作業

### 基本方針
- バージョン間の互換性を慎重に確認する
- 型定義の変更は動作に影響しないか検証する
- eslint/prettier等の設定ファイルへの影響を考慮する

### 型エラー対応のベストプラクティス

#### 1. 修正手法の優先順位
1. **型定義の正確化**: 実際の型に合わせた正しい型定義
2. **`as const`**: オブジェクトや配列のリテラル型の固定化
3. **`@ts-expect-error`**: 一時的な型エラー抑制（コメント必須）
4. **`any`の回避**: 最後の手段として使用、基本的に避ける

#### 2. 対応時の注意点
- **コードの意味を変えない**: 型修正が動作を変更しないよう注意
- **根本原因の調査**: 単純な型キャストではなく原因を理解
- **段階的修正**: 一度に全てを修正せず、一つずつ確実に対処
- **影響範囲の確認**: 型変更が他のコードに与える影響を事前調査

#### 3. 複雑な型エラーの扱い
- 自動生成クライアントの型定義更新遅延
- 外部ライブラリのバージョンアップ影響
- パッケージ間の型定義の不整合

これらの場合は**修正内容をユーザに報告**し、適切な対応方針を確認する。

## MongoDB/Mongoose作業
- スキーマ変更の影響範囲を把握する
- データベース接続文字列の機密性に注意する
- マイグレーション戦略を事前に計画する

## パッケージ管理

### 基本原則
- package-lock.jsonの変更は直接行わない
- 依存関係の競合解決は段階的に行う
- セキュリティ脆弱性の警告に適切に対応する

### npm workspaces環境での実行原則
- **npm installの実行場所**: 必ずモノレポのルートディレクトリで実行
  - ルートで実行することでworkspacesの依存関係が正しく解決される
  - 個別パッケージ内での実行は依存関係グラフの破壊につながる
- **-wフラグの使用**: 特定ワークスペースへの依存追加時は必須
  - 例: `npm install express -w packages/api`
  - これによりルートのpackage-lock.jsonが適切に更新される
- **二つの依存関係グラフの認識**:
  - ランタイムグラフ: npm workspacesが管理（package.json）
  - コンパイルタイムグラフ: TypeScript Project Referencesが管理（tsconfig.json）
  - この二つの同期が崩れるとビルドキャッシュが機能しなくなる

### package-lock.jsonのコミット戦略
- **package-lock.jsonの変更は独立したコミットに分離する**
- 機能追加・修正とpackage-lock.json更新を同一コミットに含めない
- コミットメッセージで更新理由を明確に記載
- 例: `feat: 新機能実装` → `chore: package-lock.json更新` のように分離

### 更新タイミング
- 新しい依存関係追加時
- 既存パッケージのバージョンアップ時
- セキュリティ脆弱性対応時
- 定期的なメンテナンス作業時

## Git操作

### 基本方針
- **安全性優先**: 意図しないファイルの追加を徹底的に回避
- **git add -A/git add .禁止**: 編集したファイルのみを個別に `git add [ファイル名]` で追加
- **Issue対応・PR作成**: `ISSUE_TRACKING_MODE.md`の「Git操作ワークフロー」を参照

### 技術的注意点
- 一時ファイル・自動生成ファイルの適切な除外
- カレントディレクトリとGitパス差異に注意
- リンター・フォーマッター等の自動変更への適切な対処

## PR完全性チェックリスト

### マージ前必須確認項目
- [ ] **機能要件**: 計画した全機能が実装されている
- [ ] **テスト**: 単体テスト・統合テストが全てパス
- [ ] **Lint**: エラー・警告が0件
- [ ] **型チェック**: TypeScript/型チェックが通る
- [ ] **ビルド**: 正常にビルドできる
- [ ] **CI/CD**: 全パイプラインがグリーン
- [ ] **ドキュメント**: 必要な更新が完了
- [ ] **パフォーマンス**: 想定内の性能
- [ ] **セキュリティ**: 脆弱性がない
- [ ] **後方互換性**: 既存機能への影響なし

### 作業完了の段階
1. **コード修正完了**: 機能実装・バグ修正のコード変更終了
2. **ローカル検証完了**: テスト・Lint・ビルドが全て成功
3. **PR作成可能**: 上記チェックリスト全項目クリア
4. **マージ可能**: レビュー承認・CI全パス


---
**作成日**: 2025年7月30日  
**最終更新**: 2025年8月4日（Git操作をISSUE_TRACKING_MODE.mdに統合、参照追加）  
**関連**: CLAUDE.md（メタ的作業方針）