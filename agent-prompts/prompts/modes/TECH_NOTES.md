---
mode: tech_notes
displayName: コード修正モード
autoTrigger:
  - ファイル編集を伴う作業
  - 機能追加
  - バグ修正
  - リファクタリング
exitMessage: |
  コード修正モードを終了しました。
  技術的な作業が完了しました。
---

# 技術ノウハウ - Claude Code設定

## 作業品質の基本方針

### 完了判断の慎重性
- **解決・完了は目標だが、不十分な水準での完了判断はより危険**
- 完了だと感じても、ミスや予測外の出来事が見つかった場合は迷わず作業段階を戻す
- **調査→作業→確認の段階を必要に応じて反復実行**
- 「今度こそ完了！」というノリを避け、未知の出来事には慎重に対応
- **時間がかかることは悪いことではない** - 品質と信頼性を優先
- 予期しない動作・エラーが発生した場合は根本原因の解明を徹底

### データ構造の優先

**コードよりもデータ構造の整合性を優先する**

- **データ構造が正しければ、コードは自然とシンプルになる**
- **データ構造が間違っていれば、どんなに複雑なコードでも問題を解決できない**
- 設計に迷ったら、まずデータ構造を見直す
- データの流れと変換を明確にすることで、実装の複雑さを回避できる

**実践指針**:
- 新機能の実装前に、必要なデータ構造を設計する
- 既存コードの改修時は、データ構造の整合性を確認してから着手
- 複雑なロジックが必要になったら、データ構造の見直しを検討
- 型定義やスキーマを明確にし、データの制約を表現する

### ドキュメント・テスト・コード同期の原則

#### 基本原則
**ドキュメント・テスト・コードを往復して開発する作業において、「正とするのは何か」という判断があって、そこから作業が決まる**

#### 作業フロー
1. **不整合を発見したら、まず「何を正とするか」を判断**
   - これは固定的なルールではなく、状況に応じた判断
   - 現在の開発フェーズ、変更の目的、品質の状態を考慮

2. **正の判断基準例**
   - 探索的開発：動作するコードが正（実装を通じて仕様を発見）
   - テスト駆動開発：テストが正（望ましい振る舞いを定義）
   - 仕様変更：新しい要求が正（ドキュメント・コード・テストすべて修正対象）
   - バグ修正：期待される動作が正（ドキュメントまたはテストに記載）
   - リファクタリング：テストが正（振る舞いを変えずに実装を改善）

3. **正を決めたら、それに合わせて他を修正**
   - 正とした対象は変更しない
   - 正に合わせて他の要素を修正
   - 修正後、三者の整合性を確認

4. **往復開発の実践**
   - ドキュメント ⇄ コード ⇄ テストの間を往復
   - 各段階で「今何を正としているか」を明確に意識
   - 不整合を発見したら立ち止まって判断

#### 注意点
- **「正」は固定的ではない**：開発の進行とともに変化する
- **判断の根拠を明確に**：なぜそれを正としたかを説明できるように
- **整合性の確認を怠らない**：修正後は必ず三者の一致を確認

#### コード内コメント方針
- **意図を書く**: そこに何が書いてあるかではなく、それが何を意図しているのか書く
- **コメントが必要な場面**: 複雑な手順、理解しづらい内容、名前から想像しにくい本質を発見したとき
- **型をドキュメントとして活用**: 曖昧な型には十分に絞り込める説明的な型を付ける。型で表現困難な場合のみ自然言語で補足

### 「作りながら考える」開発スタイル

多くの開発は、一見矛盾する2つの前提に基づいています。

#### 2つの前提

1. **仕様のとおりに作ってください** - 実装は必ず文章化された仕様から作成される（絶対原則）
2. **仕様は完全ではありません** - 仕様は完全ではなく、開発しながら改善される（前提）

#### 矛盾の意味、対処方法

この矛盾は「作りながら考える」という開発プロセスで重要な意味を持ちます：

1. **実装時に問題に直面したら**：
  - 勝手に解決しようとしない（第1原則違反）
  - 作業の手を止める
  - ユーザに相談する

2. **仕様の検討フェーズ**：
  - 実装で発見した問題を報告
  - 仕様の曖昧さ・矛盾・実装不可能な点を明確化
  - ユーザと協議して仕様を改善

3. **改善後の実装フェーズ**：
  - 更新された仕様に従って実装
  - 第1原則「仕様のとおりに作る」に戻る

#### 重要な注意点

- **推測での実装は禁止**: 仕様が曖昧な場合は必ず確認
- **創造的解釈は避ける**: 仕様にないものを勝手に追加しない
- **問題の早期報告**: 実装が困難・不可能と判明したら即座に報告

この循環的なプロセスにより、実装と仕様の両方が段階的に改善されます。

#### アーキテクチャ決定記録（ADR）

「作りながら考える」スタイルでは、実装中に決定した設計や仕様を記録することが重要です。

**記録すべき内容**:
- 実装の際に決定した仕様
- 型の定義と設計意図
- アーキテクチャの詳細と選択理由
- 実装の意図や背景

**目的**: 今後の実装やリファクタリングの手がかりとなるドキュメントを作成

**作成タイミング**: 実装完了後、または設計の節目で積極的に記録

## TypeScript/JavaScript作業

### 基本方針
- バージョン間の互換性を慎重に確認する
- 型定義の変更は動作に影響しないか検証する
- eslint/prettier等の設定ファイルへの影響を考慮する

### 型エラー対応のベストプラクティス

#### 1. 修正手法の優先順位
1. **型定義の正確化**: 実際の型に合わせた正しい型定義
2. **`as const`**: オブジェクトや配列のリテラル型の固定化
3. **`@ts-expect-error`**: 一時的な型エラー抑制（コメント必須）
4. **`any`の回避**: 最後の手段として使用、基本的に避ける

#### 2. 対応時の注意点
- **コードの意味を変えない**: 型修正が動作を変更しないよう注意
- **根本原因の調査**: 単純な型キャストではなく原因を理解
- **段階的修正**: 一度に全てを修正せず、一つずつ確実に対処
- **影響範囲の確認**: 型変更が他のコードに与える影響を事前調査

#### 3. 複雑な型エラーの扱い
- 自動生成クライアントの型定義更新遅延
- 外部ライブラリのバージョンアップ影響
- パッケージ間の型定義の不整合

これらの場合は**修正内容をユーザに報告**し、適切な対応方針を確認する。

## MongoDB/Mongoose作業
- スキーマ変更の影響範囲を把握する
- データベース接続文字列の機密性に注意する
- マイグレーション戦略を事前に計画する

## パッケージ管理

### 基本原則
- package-lock.jsonの変更は直接行わない
- 依存関係の競合解決は段階的に行う
- セキュリティ脆弱性の警告に適切に対応する

### package-lock.jsonのコミット戦略
- **package-lock.jsonの変更は独立したコミットに分離する**
- 機能追加・修正とpackage-lock.json更新を同一コミットに含めない
- コミットメッセージで更新理由を明確に記載
- 例: `feat: 新機能実装` → `chore: package-lock.json更新` のように分離

### 更新タイミング
- 新しい依存関係追加時
- 既存パッケージのバージョンアップ時
- セキュリティ脆弱性対応時
- 定期的なメンテナンス作業時

## Git操作

### 基本方針
- **安全性優先**: 意図しないファイルの追加を徹底的に回避
- **git add -A/git add .禁止**: 編集したファイルのみを個別に `git add [ファイル名]` で追加
- **Issue対応・PR作成**: `ISSUE_TRACKING_MODE.md`の「Git操作ワークフロー」を参照

### 技術的注意点
- 一時ファイル・自動生成ファイルの適切な除外
- カレントディレクトリとGitパス差異に注意
- リンター・フォーマッター等の自動変更への適切な対処

### 作業完了の段階
1. **コード修正完了**: 機能実装・バグ修正のコード変更終了
2. **ローカル検証完了**: テスト・Lint・ビルドが全て成功
3. **PR作成可能**: 上記チェックリスト全項目クリア
4. **マージ可能**: レビュー承認・CI全パス

## ドキュメント方針
- **README.md**: ユーザフレンドリーで総合的、リポジトリの最初のページとしての性質
- **CLAUDE.md**: 目的志向のシンプルなインデックス、「claudeが読む」ことに特化
- CLAUDE.mdはREADME.mdを参照可能だが、基礎的なパッケージ情報は省略可能
- README.mdは人が読むことを前提とした包括的な内容

